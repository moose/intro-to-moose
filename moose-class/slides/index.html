<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+RDFa 1.0//EN" "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Introduction to Moose</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<!-- metadata -->
<meta name="generator" content="S5" />
<meta name="version" content="S5 1.2a2" />
<meta name="author" content="Eric A. Meyer" />
<meta name="company" content="Complex Spiral Consulting" />
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<link rel="stylesheet" href="ui/default/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/default/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/default/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/default/opera.css" type="text/css" media="projection" id="operaFix" />
<!-- embedded styles -->
<style type="text/css" media="all">
.imgcon {width: 525px; margin: 0 auto; padding: 0; text-align: center;}
#anim {width: 270px; height: 320px; position: relative; margin-top: 0.5em;}
#anim img {position: absolute; top: 42px; left: 24px;}
img#me01 {top: 0; left: 0;}
img#me02 {left: 23px;}
img#me04 {top: 44px;}
img#me05 {top: 43px;left: 36px;}
</style>
<!-- S5 JS -->
<script src="ui/default/slides.js" type="text/javascript"></script>
<link rel="stylesheet" href="ui/custom.css" type="text/css" />
</head>
<body>

<div class="layout">
<div id="controls"><!-- DO NOT EDIT --></div>
<div id="currentSlide"><!-- DO NOT EDIT --></div>
<div id="header"></div>
<div id="footer">
  <div id="license">
    <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/us/"><img alt="Creative Commons License" style="border-width:0" src="ui/creative-commons.png" /></a>
    <br /><span xmlns:dc="http://purl.org/dc/elements/1.1/" href="http://purl.org/dc/dcmitype/Text" property="dc:title" rel="dc:type">Introduction to Moose</span> by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">David Rolsky</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/us/">Creative Commons Attribution-Share Alike 3.0 United States License</a>.
  </div>

  <h2>Introduction to Moose</h2>
</div>
</div>

<div class="presentation">

<div class="slide">
  <h1>Introduction to Moose</h1>
  <h2>Dave Rolsky</a>
</div>

<div class="slide">
  <h1>Introduce Yourselves</h1>

  <ul>
    <li>Your name</li>
    <li>What you do with Perl</li>
    <li>Why you're here today (optional)</li>
  </ul>
</div>

<div class="slide">
  <h1>Moose Summed Up</h1>

  <ul>
    <li><strong>Declarative</strong> OO sugar</li>
    <li>Introspectable</li>
    <li>Extensible (177 MooseX::* on CPAN)</li>
    <li>Community approved (1222 downstream dependents on CPAN)</li>
  </ul>
</div>

<div class="slide">
  <h1>Moose Background</h1>

  <ul>
    <li>Created by Stevan Little, first released in 2006</li>
    <li>Moose builds on Perl 5's native OO</li>
    <li>Borrows ideas from other languages, notably Perl 6</li>
    <li>Provides semantics for common operations</li>
  </ul>
</div>

<div class="slide fake-slide0">
  <h1>Part 0: Moose Concepts</h1>
</div>

<div class="slide">
  <h1>Classes</h1>

  <ul>
    <li>
      Classes have ...
      <ul>
        <li>Attributes</li>
        <li>Methods</li>
        <li>Superclasses</li>
        <li>Method modifiers</li>
        <li>Constructor and destructor</li>
        <li>One metaclass object</li>
      </ul>
    </li>
    <li>Classes do roles</li>
  </ul>
</div>

<div class="slide">
  <h1>Class Example</h1>

  <pre><code>package Person;
<span class="highlight">use Moose;</span></code></pre>

  <ul>
    <li>Poof, a Moose-based class!</li>
  </ul>
</div>

<div class="slide">
  <h1>Attributes</h1>

  <ul>
    <li>Aka property, slot, field, member variable</li>
    <li>A piece of data owned by an object</li>
  </ul>
</div>

<div class="slide">
  <h1>Attributes</h1>

  <ul>
    <li>
      Attributes have ...
      <ul>
        <li>Mutability (read-only vs read-write)</li>
        <li>An optional type</li>
        <li>Accessor methods</li>
        <li>Delegation methods</li>
        <li>Optional default value</li>
        <li>Many more features</li>
      </ul>
    </li>
    <li>Stored in the object, but don't worry about that</li>
  </ul>
</div>

<div class="slide">
  <h1>Attribute Example</h1>

  <pre><code>package Person;
use Moose;

<span class="highlight">has first_name =&gt; ( is =&gt; 'rw' );</span></code></pre>

</div>

<div class="slide">
  <h1>Methods</h1>

  <ul>
    <li>Nothing fancy here, just Perl subroutines</li>
  </ul>

  <pre><code>package Person;
use Moose;

<span class="highlight">sub greet { ... }</span></code></pre>
</div>

<div class="slide">
  <h1>Roles</h1>

  <ul>
    <li>Classes <strong>do</strong> (or consume) roles</li>
    <li>Similar to mixins and Java interfaces</li>
  </ul>
</div>

<div class="slide">
  <h1>Roles</h1>

  <ul>
    <li>Like classes, can have attributes, methods, do roles</li>
    <li>Roles can require methods</li>
    <li>Roles are composed (flattened) into classes</li>
  </ul>
</div>

<div class="slide">
  <h1>Role Example</h1>

<pre><code>package HasPermissions;
<span class="highlight">use Moose::Role;</span>

has is_admin =&gt; ( is =&gt; 'rw' );</code></pre>
</div>

<div class="slide">
  <h1>Role Example</h1>

  <p>
    And then ...
  </p>
  
<pre><code>package Person;
use Moose;

<span class="highlight">with 'HasPermissions';</span></code></pre>
</div>

<div class="slide">
  <h1>Method Modifiers</h1>

  <ul>
    <li>AKA advice</li>
    <li>&quot;<strong>Before</strong> foo(), do this first&quot;</li>
    <li>&quot;Do this <strong>after</strong> foo()&quot;</li>
    <li>&quot;Put this code <strong>around</strong> foo()&quot;</li>
  </ul>
</div>

<div class="slide">
  <h1>Before and After</h1>

<pre><code>before 'foo'
    =&gt; sub { warn 'About to call foo()' };

after  'foo'
    =&gt; sub { warn 'Leaving foo()' };</code></pre>

</div>

<div class="slide">
  <h1>Around</h1>

<pre><code>around 'foo' =&gt; sub {
    my $real_foo = shift;
    my $self     = shift;

    warn 'Just before foo()';
    my @return =
        $self-&gt;$real_foo( @_, bar =&gt; 42 );

    return (
        @return,
        'modify return values'
    );
};</code></pre>
</div>

<div class="slide">
  <h1>Type Constraints</h1>

  <ul>
    <li>NOT A FULL-BLOWN TYPE SYSTEM!</li>
    <li>But still darn useful</li>
    <li>Constrain attribute values</li>
    <li>Coerce from other types</li>
  </ul>
</div>

<div class="slide">
  <h1>Type Constraint Example</h1>

<pre><code>package Person;
use Moose;

has weight =&gt; (
    is  =&gt; 'ro',
    <span class="highlight">isa =&gt; 'Int'</span>,
);

# kaboom
Person-&gt;new( weight =&gt; 'heavy' );</code></pre>
</div>

<div class="slide">
  <h1>Delegation</h1>

  <ul>
    <li>Attributes can define delegations</li>
    <li>Lets you hide some implementation details</li>
    <li>Fewer objects to chase around</li>
  </ul>
</div>

<div class="slide">
  <h1>Delegation</h1>

<pre><code>package Person;
use Moose;

has blog_uri =&gt; (
    is      =&gt; 'rw',
    isa     =&gt; 'URI',
    <span class="highlight">handles =&gt; { 'blog_host' =&gt; 'host' },</span>
);

<span class="highlight">$person-&gt;blog_host;</span>
# really calls $person-&gt;blog_uri-&gt;host</code></pre>
</div>

<div class="slide">
  <h1>Constructors</h1>

  <ul>
    <li>Moose creates <code>new()</code> for you</li>
    <li>Provide an optional <code>BUILDARGS()</code> and <code>BUILD()</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Destructors</h1>

  <ul>
    <li>Provide an optional <code>DEMOLISH()</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Moose Meta-API</h1>

  <ul>
    <li>Answers questions like ...
      <ul>
        <li>What methods does this class have?</li>
        <li>What are its parents?</li>
        <li>What attributes does it have (including inherited attributes)?</li>
        <li>What roles does it do?</li>
        <li>Much, much, more</li>
      </ul>
    </li>
  </ul>
</div>

<div class="slide">
  <h1>Moose Meta-API</h1>

  <ul>
    <li>Not just for introspection ...
      <ul>
        <li>Add methods, attributes, roles, etc</li>
        <li>Extend and alter core features</li>
      </ul>
    </li>
  </ul>
</div>

<div class="slide">
  <h1>Why Moose?</h1>

  <ul>
    <li>A quick bit of propaganda ...</li>
  </ul>
</div>

<div class="slide">
  <h1>With Moose</h1>

  <pre><code>package Person;
use Moose;

has last_name =&gt; (
    is  =&gt; 'rw',
    isa =&gt; 'Str',
);</code></pre>
</div>

<div class="slide">
    <h1>Without Moose</h1>

    <pre class="small"><code>package Person;
use strict;
use warnings;
use Carp 'confess';

sub new {
    my $class = shift;
    my %args  = @_;
    my $self  = {};

    if (exists $args{last_name}) {
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $args{last_name}&quot;
            if ref($args{last_name});
        $self-&gt;{last_nane} = $args{last_name};
    }

    return bless $self, $class;
}

sub last_name {
    my $self = shift;

    if (@_) {
        my $value = shift;
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $value&quot;
            if ref($value);
        $self-&gt;{last_name} = $value;
    }

    return $self-&gt;{last_name};
}</code></pre>

</div>

<div class="slide">
    <h1>Side by side</h1>

    <table class="side-by-side">
        <tr>
          <td>
            <pre><code>package Person;
use Moose;

has last_name =&gt; (
    is  =&gt; 'rw',
    isa =&gt; 'Str',
);</code></pre>
            </td>
            <td>
                <pre class="small"><code>package Person;
use strict;
use warnings;
use Carp 'confess';

sub new {
    my $class = shift;
    my %args  = @_;
    my $self  = {};

    if (exists $args{last_name}) {
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $args{last_name}&quot;
            if ref($args{last_name});
        $self-&gt;{last_nane} = $args{last_name};
    }

    return bless $self, $class;
}

sub last_name {
    my $self = shift;

    if (@_) {
        my $value = shift;
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $value&quot;
            if ref($value);
        $self-&gt;{last_name} = $value;
    }

    return $self-&gt;{last_name};
}</code></pre>
            </td>
        </tr>
    </table>

</div>

<div class="slide">
    <h1>Side by side</h1>

    <table class="side-by-side">
        <tr>
            <td>
                <pre><code><span class="match-moose">package Person;</span>
use Moose;

has last_name =&gt; (
    is  =&gt; 'rw',
    isa =&gt; 'Str',
);</code></pre>
            </td>
            <td>
                <pre class="small"><code><span class="match-unsweet">package Person;</span>
use strict;
use warnings;
use Carp 'confess';

sub new {
    my $class = shift;
    my %args  = @_;
    my $self  = {};

    if (exists $args{last_name}) {
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $args{last_name}&quot;
            if ref($args{last_name});
        $self-&gt;{last_nane} = $args{last_name};
    }

    return bless $self, $class;
}

sub last_name {
    my $self = shift;

    if (@_) {
        my $value = shift;
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $value&quot;
            if ref($value);
        $self-&gt;{last_name} = $value;
    }

    return $self-&gt;{last_name};
}</code></pre>
            </td>
        </tr>
    </table>
</div>

<div class="slide">
    <h1>Side by side</h1>

    <table class="side-by-side">
        <tr>
            <td>
                <pre><code>package Person;
<span class="match-moose">use Moose;</span>

has last_name =&gt; (
    is  =&gt; 'rw',
    isa =&gt; 'Str',
);</code></pre>
            </td>
            <td>
                <pre class="small"><code>package Person;
<span class="match-unsweet">use strict;
use warnings;
use Carp 'confess';

sub new {
    my $class = shift;
    my %args  = @_;
    my $self  = {};</span>

    if (exists $args{last_name}) {
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $args{last_name}&quot;
            if ref($args{last_name});
        $self-&gt;{last_nane} = $args{last_name};
    }

    <span class="match-unsweet">return bless $self, $class;
}</span>

sub last_name {
    my $self = shift;

    if (@_) {
        my $value = shift;
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $value&quot;
            if ref($value);
        $self-&gt;{last_name} = $value;
    }

    return $self-&gt;{last_name};
}</code></pre>
            </td>
        </tr>
    </table>
</div>

<div class="slide">
    <h1>Side by side</h1>

    <table class="side-by-side">
        <tr>
            <td>
                <pre><code>package Person;
use Moose;

<span class="match-moose">has last_name =&gt; (</span>
    is  =&gt; 'rw',
    isa =&gt; 'Str',
<span class="match-moose">);</span></code></pre>
            </td>
            <td>
                <pre class="small"><code>package Person;
use strict;
use warnings;
use Carp 'confess';

sub new {
    my $class = shift;
    my %args  = @_;
    my $self  = {};

    <span class="match-unsweet">if (exists $args{last_name}) {</span>
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $args{last_name}&quot;
            if ref($args{last_name});
        <span class="match-unsweet">$self-&gt;{last_nane} = $args{last_name};
    }</span>

    return bless $self, $class;
}

sub last_name {
    my $self = shift;

    if (@_) {
        my $value = shift;
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $value&quot;
            if ref($value);
        $self-&gt;{last_name} = $value;
    }

    return $self-&gt;{last_name};
}</code></pre>
            </td>
        </tr>
    </table>
</div>

<div class="slide">
    <h1>Side by side</h1>

    <table class="side-by-side">
        <tr>
            <td>
                <pre><code>package Person;
use Moose;

has last_name =&gt; (
    <span class="match-moose">is  =&gt; 'rw',</span>
    isa =&gt; 'Str',
);</code></pre>
            </td>
            <td>
                <pre class="small"><code>package Person;
use strict;
use warnings;
use Carp 'confess';

sub new {
    my $class = shift;
    my %args  = @_;
    my $self  = {};

    if (exists $args{last_name}) {
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $args{last_name}&quot;
            if ref($args{last_name});
        $self-&gt;{last_nane} = $args{last_name};
    }

    return bless $self, $class;
}

<span class="match-unsweet">sub last_name {
    my $self = shift;

    if (@_) {
        my $value = shift;</span>
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $value&quot;
            if ref($value);
        <span class="match-unsweet">$self-&gt;{last_name} = $value;
    }

    return $self-&gt;{last_name};
}</span></code></pre>
            </td>
        </tr>
    </table>
</div>

<div class="slide">
    <h1>Side by side</h1>

    <table class="side-by-side">
        <tr>
            <td>
                <pre><code>package Person;
use Moose;

has last_name =&gt; (
    is  =&gt; 'rw',
    <span class="match-moose">isa =&gt; 'Str',</span>
);</code></pre>
            </td>
            <td>
                <pre class="small"><code>package Person;
use strict;
use warnings;
use Carp 'confess';

sub new {
    my $class = shift;
    my %args  = @_;
    my $self  = {};

    if (exists $args{last_name}) {
        <span class="match-unsweet">confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $args{last_name}&quot;
            if ref($args{last_name});</span>
        $self-&gt;{last_nane} = $args{last_name};
    }

    return bless $self, $class;
}

sub last_name {
    my $self = shift;

    if (@_) {
        my $value = shift;
        <span class="match-unsweet">confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $value&quot;
            if ref($value);</span>
        $self-&gt;{last_name} = $value;
    }

    return $self-&gt;{last_name};
}</code></pre>
            </td>
        </tr>
    </table>
</div>

<div class="slide">
    <h1>Side by side</h1>

    <table class="side-by-side">
        <tr class="incremental">
            <td>5 lines</td>
            <td>21 lines</td>
        </tr>
        <tr class="incremental">
            <td>92 characters</td>
            <td>741 characters</td>
        </tr>
        <tr>
            <td>
                <pre><code>package Person;
use Moose;

has last_name =&gt; (
    is  =&gt; 'rw',
    isa =&gt; 'Str',
);</code></pre>
            </td>
            <td>
                <pre class="small"><code>package Person;
use strict;
use warnings;
use Carp 'confess';

sub new {
    my $class = shift;
    my %args  = @_;
    my $self  = {};

    if (exists $args{last_name}) {
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $args{last_name}&quot;
            if ref($args{last_name});
        $self-&gt;{last_nane} = $args{last_name};
    }

    return bless $self, $class;
}

sub last_name {
    my $self = shift;

    if (@_) {
        my $value = shift;
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $value&quot;
            if ref($value);
        $self-&gt;{last_name} = $value;
    }

    return $self-&gt;{last_name};
}</code></pre>
            </td>
        </tr>
    </table>
</div>

<div class="slide">
    <h1>Typo?</h1>

    <pre class="small"><code>sub new {
    my $class = shift;
    my %args  = @_;
    my $self  = {};

    if (exists $args{last_name}) {
        confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
                . &quot;Validation failed for 'Str' with value $args{last_name}&quot;
            if ref($args{last_name});
        $self-&gt;{last_nane} = $args{last_name};
    }

    return bless $self, $class;
}</code></pre>
</div>

<div class="slide">
    <h1>Typo?</h1>

    <pre class="small"><code>if (exists $args{last_name}) {
    confess &quot;Attribute (last_name) does not pass the type constraint because: &quot;
            . &quot;Validation failed for 'Str' with value $args{last_name}&quot;
        if ref($args{last_name});
    $self-&gt;{last_nane} = $args{last_name};
}</code></pre>
</div>

<div class="slide">
    <h1>Typo?</h1>

    <code>$self-&gt;{last_nane} = $args{last_name};</code>
</div>

<div class="slide">
    <h1>Typo?</h1>
    <code>$self-&gt;{last_na<span class="wrong">n</span>e}</code>
</div>

<div class="slide">
    <h1>Why Moose?</h1>

    <pre><code>package Person;
use Moose;

has last_name =&gt; (
    is  =&gt; 'rw',
    isa =&gt; 'Str',
);</code></pre>
</div>

<div class="slide">
    <h1>More Why Moose?</h1>

    <ul>
      <li>Less code == fewer bugs</li>
      <li>Moose is well-tested, test your own code, not Moose</li>
      <li>Focus on <strong>what</strong>, not <strong>how</strong></li>
    </ul>
</div>

<div class="slide fake-slide0">
  <h1>Part 1: Moose Classes</h1>
</div>

<div class="slide">
  <h1>Moose Classes</h1>

  <ul>
    <li>Moose classes are Perl packages which <code>use Moose</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Moose.pm and Your Class</h1>

  <pre><code>package Person;
use Moose;</code></pre>

  <ul>
    <li><code>Moose.pm</code> provides declarative sugar</li>
    <li>Turns on <code>strict</code> and <code>warnings</code></li>
    <li>Creates metaclasses for your class: <code>Person-&gt;meta</code></li>
    <li>Moose classes automatically inherit from <code>Moose::Object</code></li>
  </ul>
</div>

<div class="slide">
  <h1>What <code>Moose::Object</code> Provides</h1>

  <ul>
    <li>Constructor - <code>new()</code></li>
    <li>Calls your <code>BUILDARGS()</code> and/or <code>BUILD()</code></li>
    <li>Calls your <code>DEMOLISH</code> during object destruction</li>
  </ul>
</div>

<div class="slide">
  <h1>BUILDARGS</h1>

  <ul>
    <li>Takes <code>@_</code>, returns a hash reference of attribute name/value pairs</li>
    <li>Accepts a hash or hashref; throws otherwise</li>
    <li>Provide your own for other cases</li>
    <li><strong>Always</strong> call <code>$class-&gt;SUPER::BUILDARGS(@_)</code> as a fallback!</li>
  </ul>
</div>

<div class="slide">
  <h1>BUILDARGS Example</h1>

  <pre><code>package Person;
use Moose;

sub BUILDARGS {
    my $class = shift;

    if ( @_ == 1 &amp;&amp; ! ref $_[0] ) {
        <span class="highlight">return { ssn =&gt; $_[0] };</span>
    }
    <span class="highlight">return $class-&gt;SUPER::BUILDARGS(@_)</span>;
}

<span class="highlight">Person-&gt;new('123-45-6789')</span></code></pre>
</div>

<div class="slide">
  <h1>BUILD</h1>

  <ul>
    <li>Called after object is created, before <code>new</code> returns</li>
    <li>Chance to do more complex validation, set complex attributes</li>
    <li>Called in reverse inheritance order, parents to children</li>
    <li>Return value is ignored</li>
  </ul>
</div>

<div class="slide">
  <h1>BUILD Example</h1>

  <pre><code>package Person;
use Moose;

sub BUILD {
    my $self = shift;

    if ( $self-&gt;country_of_residence
         eq 'USA' ) {
        die 'All US residents'
            . ' must have an SSN'
            unless $self-&gt;has_ssn;
    }
}</code></pre>
</div>

<div class="slide">
  <h1>Object Construction a la Moose</h1>

  <pre><code>Person-&gt;new(@_)</code></pre>

  <ol style="margin-top: 0">
    <li>Calls <code>Person-&gt;BUILDARGS(@_)</code> to turn <code>@_</code> into a hashref</li>
    <li>Blesses a reference</li>
    <li>Populates attributes based on the hashref from #1</li>
    <li>Calls <code>$new_object-&gt;BUILDALL($constructor_args)</code>
        <br />... which calls all <code>BUILD</code> methods</li>    
    <li>Returns the object</li>
  </ol>
</div>

<div class="slide">
  <h1>The Object is Opaque</h1>

  <ul>
    <li>Technically it's a hash reference</li>
    <li><span class="wrong">If you <em>ever</em> treat it as one <strong>you are doing it wrong!</strong></span></li>
  </ul>
</div>

<div class="slide">
  <h1>DEMOLISH</h1>

  <ul>
    <li>Like <code>DESTROY</code>, but Moose makes sure all <code>DEMOLISH</code> methods in a hierarchy are called</li>
    <li>Called in normal inheritance order, children to parents</li>
  </ul>
</div>

<div class="slide">
  <h1>extends</h1>

  <ul>
    <li><code>extends</code> is sugar for declaring parent classes</li>
    <li>Also ensures metaclass compatibility between parent and child</li>
    <li>Do not <code>use base</code></li>
  </ul>

  <pre><code>package Employee;
use Moose;
<span class="highlight">extends 'Person';</span></code></pre>
</div>

<div class="slide">
  <h1>extends</h1>

  <ul>
    <li>Each call to <code>extends</code> <strong>resets</strong> your parents</li>
  </ul>

  <h2 class="wrong">Wrong</h2>

  <pre><code>package EvilEmployee;
use Moose;
extends 'Person';
extends 'Thief';</code></pre>

  <h2 class="right">Right</h2>

  <pre><code>package EvilEmployee;
use Moose;
extends 'Person', 'Thief';</code></pre>
</div>

<div class="slide">
  <h1>Extending un-Moose-y Parents</h1>

  <pre><code>package My::LWP;
use Moose;
extends 'LWP';</code></pre>

  <ul>
    <li>No <code>Moose::Object</code>, so ...
      <ul>
        <li>No attribute-handling <code>new()</code></li>
        <li>No <code>BUILDARGS()</code> or <code>BUILD()</code></li>
        <li>No <code>DEMOLISH()</code></li>
      </ul>
    </li>
    <li>But see <code>MooseX::NonMoose</code> for a workaround</li>
  </ul>
</div>  

<div class="slide">
  <h1><code>override</code> and <code>super</code></h1>

  <ul>
    <li><code>override</code> is another method modifier</li>
    <li>An alternative to Perl's <code>SUPER::</code></li>
    <li><em>Declares</em> your intent to override a method</li>
  </ul>
</div>

<div class="slide">
  <h1><code>override</code> and <code>super</code></h1>

  <pre><code>package Employee;
use Moose;

<span class="current incremental">extends 'Person';</span>

<span class="incremental">override</span> work =&gt; sub {
    my $self = shift;

    die "Pay me first"
        unless $self-&gt;got_paid;
    <span class="incremental">super();</span>
}<span class="incremental">;</span></code></pre>
</div>

<div class="slide">
  <h1>Caveat <code>super</code></h1>

  <ul>
    <li>Mostly like <code>$self-&gt;SUPER::work(@_)</code></li>
    <li><strong>But</strong> cannot change <code>@_</code>!</li>
    <li>Binds the parent's method at compile time</li>
    <li>Parent determined by checking <code>Child-&gt;meta()-&gt;superclasses()</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Minimal Attributes</h1>

  <ul>
    <li><code>has 'foo'</code></li>
    <li>Use <code>is =&gt; 'ro'</code> or <code>is =&gt; 'rw'</code></li>
    <li>Attributes without "is" have no accessors</li>
  </ul>
</div>

<div class="slide">
  <h1>Read-write attributes</h1>

  <pre><code>package Person;
use Moose;

has first_name =&gt; ( <span class="highlight">is =&gt; 'rw'</span> );

my $person =
    Person-&gt;new( first_name =&gt; 'Dave' );

$person-&gt;first_name('Stevan');
print $person-&gt;first_name; # Stevan</code></pre>

</div>

<div class="slide">
  <h1>Read-only attributes</h1>

  <pre><code>package Person;
use Moose;

has first_name =&gt; ( <span class="highlight">is =&gt; 'ro'</span> );

my $person =
    Person-&gt;new( first_name =&gt; 'Dave' );

$person-&gt;first_name('Stevan'); # dies</code></pre>

</div>

<div class="slide">
  <h1>There is More to Come</h1>

  <ul>
    <li>Attributes have a <em>lot</em> of features</li>
  </ul>
</div>

<div class="slide">
  <h1>Cleaning Up Moose Droppings</h1>

  <pre><code>package Person;
use Moose;

# true
Person-&gt;can('extends');</code></pre>

  <ul>
    <li>Not very hygienic</li>
  </ul>
</div>

<div class="slide">
  <h1>Cleaning Up Moose Droppings</h1>

  <pre><code>package Person;
use Moose;

...

<span class="highlight">no Moose;</span>

# false
Person-&gt;can('extends');</code></pre>
</div>

<div class="slide">
  <h1>Cleaning Up Moose Droppings</h1>

  <pre><code>package Person;
<span class="highlight">use namespace::autoclean;</span>
use Moose;

...

# false
Person-&gt;can('extends');</code></pre>
</div>

<div class="slide">
  <h1>No Moose</h1>

  <ul>
    <li>Cleaning up is a best practice</li>
    <li>Say <code>no Moose</code> at the end of a package</li>
    <li>Or <code>use namespace::autoclean</code> at the top</li>
    <li>Just do it</li>
  </ul>
</div>

<div class="slide">
  <h1>Immutability</h1>

  <ul>
    <li><span style="font-family: URW Chancery L; font-size: 120%">Stevan's Incantation of Fleet-Footedness</span></li>
  </ul>

  <pre><code>package Person;
use Moose;

<span class="highlight">__PACKAGE__-&gt;meta-&gt;make_immutable;</span></code></pre>
</div>

<div class="slide">
  <h1>What <code>make_immutable</code> does</h1>

  <ul>
    <li>Magic</li>
    <li>Uses <code>eval</code> to "inline" a constructor</li>
    <li>Memoizes a lot of meta-information</li>
    <li>Makes loading your class slower</li>
    <li>Makes object creation <em>much</em> faster</li>
  </ul>
</div>

<div class="slide">
  <h1>When to Immutabilize?</h1>

  <ul>
    <li><em>Almost</em> always</li>
    <li>Startup time vs execution time</li>
  </ul>
</div>

<div class="slide">
  <h1>Classes Summary</h1>

  <ul>
    <li><code>use Moose</code></li>
    <li><code>Class-&gt;meta</code></li>
    <li><code>Moose::Object</code> base class</li>
    <li><code>extends</code>, <code>override</code>, and <code>super</code></li>
    <li>Simple attributes: <code>has</code>, <code>is&nbsp;=&gt;&nbsp;'ro'</code>, &amp; <code>is&nbsp;=&gt;&nbsp;'rw'</code></li>
    <li><code>no Moose</code></li>
    <li><code>__PACKAGE__-&gt;meta-&gt;make_immutable</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Questions?</h1>
</div>  

<div class="slide">
  <h1>Exercises</h1>

  <pre># cd exercises

# perl bin/prove -lv t/00-prereq.t

# perl install-moose (if needed)

# perl bin/prove -lv t/01-classes.t

# edit lib/Person.pm and lib/Employee.pm

Iterate til this passes all its tests</pre>
</div>

<div class="slide fake-slide0">
  <h1>Part 2: Roles</h1>
</div>

<div class="slide">
  <h1>Just What Is a Role?</h1>

  <ul>
    <li>Mixin? Interface? Trait?</li>
    <li>Yes ... and more!</li>
  </ul>
</div>

<div class="slide">
  <h1>Roles - State <strong>and</strong> Behavior</h1>

  <pre><code>package HasPermissions;
use Moose::Role;
<span class="current incremental"># state
has access_level =&gt; ( is =&gt; 'rw' );</span>

<span class="incremental"># behavior
sub can_access {
    my $self     = shift;
    my $required = shift;

    return $self-&gt;access_level
             &gt;= $required;
}</span></code></pre>

</div>

<div class="slide">
  <h1>Roles Can Define Interfaces</h1>

  <pre><code>package Printable;
use Moose::Role;

requires 'as_string';</code></pre>
</div>

<div class="slide">
  <h1>Roles Can Do All Three</h1>

  <pre><code>package Printable;
use Moose::Role;

requires 'as_string';

has has_been_printed =&gt; ( is =&gt; 'rw'  );

sub print {
    my $self = shift;
    print $self-&gt;as_string;
    $self-&gt;has_been_printed(1);
}</code></pre>
</div>

<div class="slide">
  <h1>Classes Consume Roles</h1>

  <pre><code>package Person;
use Moose;

with 'HasPermissions';</code></pre>
</div>

<div class="slide">
  <h1>Classes Consume Roles</h1>

<pre><code>my $person = Person-&gt;new(
    first_name   =&gt; 'Kenichi',
    last_name    =&gt; 'Asai',
    access_level =&gt; 42,
);

print $person-&gt;full_name
    . ' has '
    . $person-&gt;can_access(42)
        ? 'great power'
        : 'little power';</code></pre>
</div>

<div class="slide">
  <h1>Roles in Practice</h1>

  <ul>
    <li>Consuming a role =~ inlining the role</li>
  </ul>
</div>

<div class="slide">
  <h1>In Other Words ...</h1>

<pre><code>package Person;
use Moose;

<span class="highlight">with 'Printable';</span></code></pre>
</div>

<div class="slide">
  <h1>In Other Words ...</h1>

<pre><code>package Person;
use Moose;

<span class="delete">with 'Printable';</span>

<span class="highlight">has has_been_printed =&gt; ( is =&gt; 'rw'  );

sub print {
    my $self = shift;
    print $self-&gt;as_string;
    $self-&gt;has_been_printed(1);
}</span></code></pre>
</div>

<div class="slide">
  <h1>Except</h1>

  <ul>
    <li>Role consumption is introspectable</li>
  </ul>

  <pre><code>if ( Person-&gt;does('Printable') ) { ... }

# or ...

Person-&gt;meta-&gt;does_role('Printable')</code></pre>

</div>

<div class="slide">
  <h1>These Names Are the Same</h1>

  <ul>
    <li>What if a role and class define the same method?</li>
    <li>A class's <em>local</em> methods win over the role's</li>
    <li>The role's methods win over the class's <em>inherited</em> methods</li>
  </ul>
</div>

<div class="slide">
  <h1>Conflicts Between Roles</h1>

  <ul>
    <li>Two roles with a method of the same name</li>
    <li>Generates a compile-time error when consumed by a class</li>
  </ul>
</div>

<div class="slide">
  <h1>Conflict Example</h1>

  <pre><code>package IsFragile;
use Moose::Role;

sub break { ... }

package CanBreakdance;
use Moose::Role;

sub break { ... }</code></pre>
</div>

<div class="slide">
  <h1>Conflict Example</h1>

  <pre><code>package FragileDancer;
use Moose;

<span class="highlight">with 'IsFragile', 'CanBreakdance';</span></code></pre>

  <ul>
    <li>Only one <code>with</code>!</li>
  </ul>
</div>

<div class="slide">
  <h1>Conflict Resolution</h1>

  <ul>
    <li>The consuming class must resolve the conflict by implementing the method</li>
    <li>Can use some combination of method exclusion and aliasing</li>
  </ul>
</div>

<div class="slide">
  <h1>Conflicts Are a Smell</h1>

  <ul>
    <li>Roles are about semantics!</li>
    <li>Roles have a <em>meaning</em></li>
    <li>Method name conflicts smell like bad design</li>
  </ul>
</div>

<div class="slide">
  <h1>Roles With Roles</h1>

  <pre><code>package Comparable;
use Moose::Role;

requires 'compare';</code></pre>
</div>

<div class="slide">
  <h1>Roles With Roles</h1>

  <pre><code>package TestsEquality;
use Moose::Role;

with 'Comparable';

sub is_equal {
    my $self = shift;
    return $self-&gt;compare(@_) == 0;
}</code></pre>
</div>

<div class="slide">
  <h1>And then ...</h1>

  <pre><code>package Integer;
use Moose;

with 'TestsEquality';

# Satisfies the Comparable role
sub compare { ... }

Integer-&gt;does('TestsEquality'); # true
Integer-&gt;does('Comparable'); # also true!</code></pre>
</div>

<div class="slide">
  <h1>Name Conflicts Between Roles</h1>

  <pre><code>package HasSubProcess;
use Moose::Role;

<span class="highlight">sub execute { ... }</span>

package Killer;
use Moose::Role;

with 'HasSubProcess';

<span class="highlight">sub execute { ... }</span></code></pre>
</div>

<div class="slide">
  <h1>Delayed Conflict</h1>

  <pre><code>package SysadminAssassin;
with 'Killer';</code></pre>

  <ul>
    <li><code>SysadminAssassin</code> must implement its own <code>execute</code></li>
    <li>But loading the <code>Killer</code> role by itself does not cause an error</li>
  </ul>
</div>

<div class="slide">
  <h1>Roles as Interfaces</h1>

  <ul>
    <li>Roles can <code>require</code> methods of their consumers</li>
    <li>Compile-time checks</li>
    <li>Method must exist when the role is consumed</li>
  </ul>
</div>

<div class="slide">
  <h1>The Attribute Gotcha</h1>

<pre><code>package HasSize;
use Moose::Role;

<span class="current incremental">requires 'size';</span>

package Shirt;
use Moose;

<span class="incremental">with 'HasSize';

has size => ( is => 'ro' );</span></code></pre>
</div>

<div class="slide">
  <h1>The Attribute Gotcha Workaround</h1>

  <pre><code>package HasSize;
use Moose::Role;

requires 'size';

package Shirt;
use Moose;

has size => ( is => 'ro' );

with 'HasSize';</code></pre>
</div>

<div class="slide">
  <h1>Compile-time Is a Lie</h1>

  <ul>
    <li>Really, it's <em>package load</em> time</li>
    <li>That's run-time, but before the "real" run-time</li>
    <li>Moose does not rewire Perl, it's just sugar!</li>
    <li>(but <code>MooseX::Declare</code> <em>does</em> rewire Perl)</li>
  </ul>
</div>

<div class="slide">
  <h1>Enforcing Roles</h1>

  <pre><code>package Comparison;
use Moose;

has [ 'left', 'right' ] => (
    is   => 'ro',
    <span class="highlight">does => 'Comparable',</span>
);
</code></pre>

  <ul>
    <li>A sneak peek at type constraints</li>
  </ul>
</div>


<div class="slide">
  <h1>Roles Can Be Applied to Objects</h1>

  <pre><code>use Moose::Util qw( apply_all_roles );

my $fragile_person = Person-&gt;new( ... );
apply_all_roles( $fragile_person,
                 'IsFragile' );</code></pre>

  <ul>
    <li>Does not change the <code>Person</code> class</li>
    <li>Works with non-Moose classes, great for monkey-patching!</li>
  </ul>
</div>

<div class="slide">
  <h1>Roles Are Dirty Too</h1>

  <ul>
    <li>Once again, clean up those Moose droppings</li>
  </ul>

  <pre><code>package Comparable;
use Moose::Role;

requires 'compare';

<span class="highlight">no Moose::Role;</span></code></pre>

  <ul>
    <li>But roles cannot be made immutable</li>
  </ul>
</div>

<div class="slide">
  <h1>The Zen of Roles</h1>

  <ul>
    <li>Roles represent discrete units of ...
      <ul>
        <li>state</li>
        <li>behavior</li>
        <li>interface</li>
      </ul>
    </li>
    <li>Roles are shareable between unrelated classes</li>
    <li>Roles are what a class <em>does</em>, not what it <em>is</em></li>
    <li>Roles <em>add</em> functionality, inheritance <em>specializes</em></li>
  </ul>
</div>

<div class="slide">
  <h1>Abstract Examples</h1>

  <ul>
    <li>Human <em>@ISA</em> Animal</li>
    <li>Human <em>does</em> Toolmaker (as <em>does</em> Chimpanzee)</li>
    <li>Car <em>@ISA</em> Vehicle</li>
    <li>Car <em>does</em> HasEngine</li>
  </ul>
</div>

<div class="slide">
  <h1>Real Examples</h1>

  <ul>
    <li>Objects representing SQL database components and queries
      <ul>
        <li>Schema, Table, Column, ColumnAlias</li>
        <li>Select, Insert, Update, Delete</li>
      </ul>
    </li>
  </ul>
</div>

<div class="slide">
  <h1>Real Examples</h1>

  <ul>
    <li>Column and ColumnAlias both <em>do</em> ColumnLike</li>
    <li>ColumnLike things can be used in certain parts of queries</li>
    <li>All queries <em>do</em> HasWhereClause</li>
    <li>Select <em>does</em> Comparable and Selectable (for subselects)</li>
    <li>A where clause requires its components to <em>do</em> Comparable</li>
  </ul>
</div>

<div class="slide">
  <h1>Roles Summary</h1>

  <ul>
    <li>Roles can define an interface with <code>requires</code></li>
    <li>Roles can have state (attributes) and behavior (methods)</li>
    <li>Roles can mix interface, state, &amp; behavior</li>
    <li>Roles are composed (flattened) into classes</li>
    <li>Roles can do other roles</li>
    <li>Roles can be used as a type in APIs (must do Comparable)</li>
  </ul>
</div>

<div class="slide">
  <h1>Questions?</h1>
</div>  

<div class="slide">
  <h1>Exercises</h1>

  <pre># cd exercises
# perl bin/prove -lv t/02-roles.t

Iterate til this passes all its tests</pre>
</div>

<div class="slide fake-slide0">
  <h1>Part 3: Basic Attributes</h1>
</div>

<div class="slide">
  <h1>Attributes Are Huge</h1>

  <ul>
    <li>Moose's biggest feature</li>
    <li>The target of <em>many</em> MooseX modules</li>
  </ul>
</div>

<div class="slide">
  <h1>Quick Review</h1>

  <ul>
    <li>Declared with <code>has</code></li>
    <li>Read-only or read-write</li>
  </ul>

  <pre><code>package Shirt;
use Moose;

has 'color'     =&gt; ( is =&gt; 'ro' );
has 'is_ripped' =&gt; ( is =&gt; 'rw' );</code></pre>
</div>

<div class="slide">
  <h1>Required-ness</h1>

  <ul>
    <li>Required means "must be passed to the constructor"</li>
    <li>But can be <code>undef</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Required-ness</h1>

  <pre><code>package Person;
use Moose;

has first_name =&gt; (
    is       =&gt; 'ro',
    <span class="current incremental">required =&gt; 1,</span>
);

<span class="incremental">Person-&gt;new( first_name =&gt; undef ); # ok
Person-&gt;new(); # kaboom</span></code></pre>
</div>

<div class="slide">
  <h1>Default and Builder</h1>

  <ul>
    <li>Attributes can have defaults</li>
    <li>Simple non-reference scalars (number, string)</li>
    <li>Subroutine reference</li>
    <li>A builder method</li>
  </ul>
</div>

<div class="slide">
  <h1>Default</h1>

  <ul>
    <li>Can be a non-reference scalar (including <code>undef</code>)</li>
  </ul>

  <pre><code>package Person;
use Moose;

has bank =&gt; (
    is      =&gt; 'rw',
    default =&gt; 'Spire FCU',
);</code></pre>
</div>

<div class="slide">
  <h1>Default</h1>

  <ul>
    <li>Can be a subroutine reference</li>
  </ul>

  <pre><code>package Person;
use Moose;

has bank =&gt; (
    is      =&gt; 'rw',
    default =&gt;
        sub { Bank-&gt;new(
                  name =&gt; 'Spire FCU' ) },
);</code></pre>
</div>

<div class="slide">
  <h1>Subroutine Reference Default</h1>

  <ul>
    <li>Called as a method on the object</li>
    <li>Called anew for each object</li>
  </ul>
</div>

<div class="slide">
  <h1>Why No Other Reference Types?</h1>

  <pre><code>package Person;
use Moose;

has bank =&gt; (
    is      =&gt; 'rw',
    <span class="wrong">default =&gt; Bank-&gt;new(
                   name =&gt; 'Spire FCU' ),</span>
);</code></pre>

  <ul>
    <li>Now <strong>every</strong> person shares the <strong>same</strong> Bank object!</li>
  </ul>
</div>

<div class="slide">
     <h1>Defaulting to an Empty Reference</h1>

  <pre><code>package Person;
use Moose;

has packages =&gt; (
    is      =&gt; 'rw',
    default =&gt; <span class="highlight">sub { [] }</span>,
);</code></pre>
</div>

<div class="slide">
  <h1>What if I Want to Share?</h1>

  <pre><code>package Person;
use Moose;

my $highlander_bank =
    Bank-&gt;new(
        name =&gt; 'Clan MacLeod Trust' );

has bank =&gt; (
    is      =&gt; 'rw',
    default =&gt; sub { $highlander_bank },
);</code></pre>
</div>

<div class="slide">
  <h1>Builder</h1>

  <ul>
    <li>A method <em>name</em></li>
    <li>When called, this method returns the default value</li>
  </ul>
</div>

<div class="slide">
  <h1>Builder</h1>

  <pre><code>package Person;
use Moose;

has bank =&gt; (
    is      =&gt; 'rw',
    builder =&gt; '_build_bank',
);

sub _build_bank {
    my $self = shift;
    return Bank-&gt;new(
        name => 'Spire FCU' );
}</code></pre>
</div>

<div class="slide">
  <h1>Default vs Builder</h1>

  <ul>
    <li>Use default for simple scalars</li>
    <li>Use default to return empty references</li>
    <li>Use default for <em>very</em> trivial subroutine references</li>
    <li>Use builder for everything else</li>
  </ul>
</div>

<div class="slide">
  <h1>Builder Bonuses</h1>

  <ul>
    <li>Can be overridden and method modified, because it's called by <em>name</em></li>
    <li>Roles can require a builder</li>
  </ul>
</div>
      
<div class="slide">
  <h1>Role Requires Builder</h1>

  <pre><code>package HasBank;
use Moose::Role;

requires '_build_bank';

has bank =&gt; (
    is      =&gt; 'ro',
    builder =&gt; '_build_bank',
);</code></pre>
</div>

<div class="slide">
  <h1>Lazy, Good for Nothin' Attributes</h1>

  <ul>
    <li>Normally, defaults are generated during object construction</li>
    <li>This can be expensive</li>
    <li>We want to default to <code>$self-&gt;size * 2</code>, but attribute initialization order is unpredictable</li>
    <li>Use lazy attributes!</li>
  </ul>
</div>

<div class="slide">
  <h1>The Power of Dynamic Defaults</h1>

  <pre><code>package Person;
use Moose;

has shoe_size =&gt; (
    is       =&gt; 'ro',
    required =&gt; 1,
);</code></pre>
</div>

<div class="slide">
  <h1>The Power of Dynamic Defaults</h1>

  <pre><code>has shoes =&gt; (
    is      =&gt; 'ro',
    <span class="highlight">lazy    =&gt; 1,</span>
    builder => '_build_shoes',
);

sub _build_shoes {
    my $self = shift;

    return Shoes-&gt;new(
        size =&gt; <span class="highlight">$self-&gt;shoe_size</span> );
}</code></pre>
</div>

<div class="slide">
  <h1>Lazy is Good</h1>

  <ul>
    <li>Lazy defaults are executed when the attribute is read</li>
    <li>Can see other object attributes</li>
    <li>Still need to watch out for circular laziness</li>
  </ul>
</div>    

<div class="slide">
  <h1>Clearer and Predicate</h1>

  <ul>
    <li>Attributes can have a value, including <code>undef</code>, or not</li>
    <li>Can clear the value with a clearer method</li>
    <li>Can check for the existence of a value with a predicate method</li>
    <li>By default, these methods are not created</li>
  </ul>
</div>

<div class="slide">
  <h1>Clearer and Predicate</h1>

  <pre><code>package Person;
use Moose;

has account =&gt; (
    is        =&gt; 'ro',
    lazy      =&gt; 1,
    builder   =&gt; '_build_account',
    <span class="highlight">clearer   =&gt; '_clear_account',
    predicate =&gt; 'has_account',</span>
);</code></pre>
</div>

<div class="slide">
  <h1>Clearer and Lazy Defaults</h1>

  <ul>
    <li>Lazy defaults are good for computed attributes</li>
    <li>Clear the attribute when the source data changes</li>
    <li>Recalculated at next access</li>
  </ul>
</div>

<div class="slide">
  <h1>Renaming constructor arguments</h1>

  <ul>
    <li>By default, constructor names = attribute names</li>
    <li>Use <code>init_arg</code> to change this</li>
    <li>Set <code>init_arg =&gt; undef</code> to make it unconstructable</li>
  </ul>
</div>

<div class="slide">
  <h1>Some <code>init_arg</code> examples</h1>

  <pre><code>package Person;
use Moose;

has shoe_size => (
    is       =&gt; 'ro',
    <span class="highlight">init_arg =&gt; 'foot_size',</span>
);

Person-&gt;new( <span class="wrong">shoe_size =&gt; 13</span> );

my $person =
    Person-&gt;new( <span class="right">foot_size =&gt; 13</span> );
print $person-&gt;shoe_size;</code></pre>
</div>

<div class="slide">
  <h1>Some <code>init_arg</code> examples</h1>

<pre><code>package Person;
use Moose;

has shoes => (
    is       =&gt; 'ro',
    <span class="highlight">init_arg =&gt; undef,</span>
);

Person-&gt;new( <span class="wrong">shoes =&gt; Shoes-&gt;new</span> );</code></pre>
</div>

<div class="slide">
  <h1>Why Set <code>init_arg =&gt; undef</code>?</h1>

  <ul>
    <li>Use this with a lazy default for attributes-as-cache</li>
    <li>Compute the value as needed</li>
    <li>Ensure that it is always generated correctly (not set by constructor)</li>
    <li>Use triggers or method modifiers (coming soon) to clear the value</li>
  </ul>
</div>

<div class="slide">
  <h1>Attribute Inheritance</h1>

  <ul>
    <li>By default, subclasses inherit attribute as-is</li>
    <li>Can change some attribute parameters in subclasses
      <ul>
        <li>default</li>
        <li>builder</li>
        <li>required</li>
        <li>lazy</li>
        <li>others we've not yet covered</li>
      </ul>
    </li>
  </ul>
</div>   

<div class="slide">
  <h1>Attribute Inheritance Example</h1>

  <pre><code>package Employee;
use Moose;

extends 'Person';

has '<span class="highlight">+first_name</span>' =&gt; (
    default =&gt; 'Joe',
);</code></pre>
</div>

<div class="slide">
  <h1>Attribute Inheritance Warning</h1>

  <ul>
    <li>An attribute is a contract about a class's API</li>
    <li>Don't break that contract in a subclass</li>
    <li>Especially important in the context of types</li>
  </ul>
</div>

<div class="slide">
  <h1>Changing Accessor Names</h1>

  <pre><code>package Person;
use Moose;

has first_name =&gt; (
    <span class="highlight">accessor</span> =&gt; 'first_name',
);</code></pre>

  <ul>
    <li>The long-hand version of <code>is =&gt; 'rw'</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Changing Accessor Names</h1>

  <pre><code>package Person;
use Moose;

has first_name =&gt; (
    <span class="highlight">reader</span> =&gt; 'first_name',
    <span class="highlight">writer</span> =&gt; undef,
);</code></pre>

  <ul>
    <li>The long-hand version of <code>is =&gt; 'ro'</code></li>
  </ul>
</div>


<div class="slide">
  <h1>Changing Accessor Names</h1>

  <pre><code>package Person;
use Moose;

has first_name =&gt; (
    <span class="highlight">reader</span> =&gt; 'get_first_name',
    <span class="highlight">writer</span> =&gt; 'set_first_name',
);</code></pre>
</div>

<div class="slide">
  <h1>Changing Accessor Names</h1>

  <pre><code>package Person;
use Moose;

has first_name =&gt; (
    <span class="highlight">is</span>     =&gt; 'rw',
    <span class="highlight">writer</span> =&gt; '_first_name',
);</code></pre>

  <ul>
    <li>Can also mix-and-match <code>is</code> and explicit names</li>
  </ul>
</div>

<div class="slide">
  <h1>ETOOMUCHTYPING</h1>

  <ul>
    <li><code>MooseX::FollowPBP</code><br /><code>get_foo</code> and <code>set_foo</code></li>
    <li><code>MooseX::SemiAffordanceAccessor</code><br /><code>foo</code> and <code>set_foo</code></li>
  </ul>
</div>

<div class="slide">
  <h1>ETOOMUCHTYPING</h1>

  <pre><code>package Person;
use Moose;
<span class="highlight">use MooseX::SemiAffordanceAccessor;</span>

has first_name =&gt; (
    is =&gt; 'rw',
);</code></pre>

  <ul>
    <li>Creates <code>first_name</code> and <code>set_first_name</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Basic Attributes Summary</h1>

  <ul>
    <li>Attributes can be <code>required</code></li>
    <li>Attributes can have a <code>default</code> or <code>builder</code></li>
    <li>Attributes with a default or builder can be <code>lazy</code></li>
    <li>Attributes can have a <code>clearer</code> and/or <code>predicate</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Basic Attributes Summary</h1>

  <ul>
    <li>An attribute's constructor name can be changed with <code>init_arg</code></li>
    <li>A subclass can alter its parents' attributes</li>
    <li>Attribute accessor names can be changed</li>
  </ul>
</div>

<div class="slide">
  <h1>Questions?</h1>
</div>  

<div class="slide">
  <h1>Exercises</h1>

  <pre># cd exercises
# perl bin/prove -lv \
      t/03-basic-attributes.t

Iterate til this passes all its tests</pre>
</div>

<div class="slide fake-slide0">
  <h1>Part 4: Method Modifiers</h1>
</div>

<div class="slide">
  <h1>What is a Method Modifier</h1>

  <ul>
    <li>Apply to an existing method</li>
    <li>... that comes from a parent class, the current class, or a role</li>
    <li>Roles can provide modifiers that are applied at composition time</li>
  </ul>
</div>

<div class="slide">
  <h1>What Are Method Modifiers For?</h1>

  <ul>
    <li>"Inject" behavior</li>
    <li>Add behavior to generated methods (accessors, delegations)</li>
    <li>Added from a role, can modify existing behavior</li>
  </ul>
</div>

<div class="slide">
  <h1>Before and After</h1>

  <ul>
    <li>Simplest modifiers - <code>before</code> and <code>after</code></li>
    <li>Guess when they run!</li>
  </ul>
</div>

<div class="slide">
  <h1>Uses for <code>before</code></h1>

  <ul>
    <li>As a pre-call check</li>
  </ul>

  <pre><code>package Person;
use Moose;

before work =&gt; sub {
    my $self = shift;
    die 'I have no job!'
        unless $self-&gt;has_title;
};</code></pre>
</div>    

<div class="slide">
  <h1>Uses for <code>before</code></h1>

  <ul>
    <li>Logging/Debugging</li>
  </ul>

  <pre><code>package Person;
use Moose;

before work =&gt; sub {
    my $self = shift;
    return unless $DEBUG;

    warn "Called work on ",
         $self-&gt;full_name,
         "with the arguments: [@_]\n";
};</code></pre>
</div>    

<div class="slide">
  <h1>Uses for <code>after</code></h1>

  <ul>
    <li>Also works for logging/debugging</li>
    <li>Post-X side-effects (recording audit info)</li>
  </ul>

  <pre><code>package Person;
use Moose;

after work =&gt; sub {
    my $self = shift;
    $self-&gt;work_count(
        $self-&gt;work_count + 1 );
};</code></pre>
</div>

<div class="slide">
  <h1>Other Uses</h1>

  <ul>
    <li>Modifiers are useful for adding behavior to generated methods</li>
  </ul>
</div>

<div class="slide">
  <h1>More Modifier Examples</h1>

  <pre><code>has password =&gt; (
     is      =&gt; 'rw',
     clearer =&gt; 'clear_password',
);
has hashed_password =&gt; (
     is      =&gt; 'ro',
     builder =&gt; '_build_hashed_password',
     clearer =&gt; '_clear_hashed_password',
);
after clear_password =&gt; sub {
    my $self = shift;
    $self-&gt;_clear_hashed_password;
};</code></pre>
</div>

<div class="slide">
  <h1><code>before</code> and <code>after</code> Limitations</h1>

  <ul>
    <li>Cannot alter method parameters</li>
    <li>Cannot alter return value</li>
    <li>But <strong>can</strong> throw an exception</li>
  </ul>
</div>

<div class="slide">
  <h1>The <code>around</code> Modifier</h1>

  <ul>
    <li>The big gun</li>
    <li>Can alter parameters <strong>and/or</strong> return values</li>
    <li>Can skip calling the wrapped method entirely</li>
  </ul>
</div>

<div class="slide">
  <h1>The power of <code>around</code></h1>

  <pre><code>around insert =&gt; sub {
    my $orig = shift;
    my $self = shift;

    $self-&gt;_validate_insert(@_);

    my $new_user =
        $self-&gt;$orig(
            $self-&gt;_munge_insert(@_) );

    $new_user-&gt;_assign_uri;
    return $new_user;
};</code></pre>
</div>

<div class="slide">
  <h1>Modifier Order</h1>

  <ul>
    <li>Before runs in order from last to first</li>
    <li>After runs in order from first to last</li>
    <li>Around runs in order from last to first</li>
  </ul>
</div>

<div class="slide">
  <h1>Modifier Order Illustrated</h1>

<pre>
<span class="current incremental">before 2
 before 1</span>
  <span class="incremental">around 2
   around 1</span>
    <span class="incremental">wrapped method</span>
   <span class="incremental">around 1
  around 2</span>
 <span class="incremental">after 1
after 2</span>
</pre>
</div>

<div class="slide">
  <h1>Modifiers in Roles</h1>

  <ul>
    <li>Roles can use these modifiers</li>
    <li>Very powerful!</li>
  </ul>
</div>

<div class="slide">
  <h1>Modifiers in Roles</h1>

  <pre><code>package IsUnreliable;
use Moose::Role;

<span class="highlight">requires 'run';

around run</span> =&gt; sub {
    my $orig = shift;
    my $self = shift;

    return if rand(1) &lt; 0.5;

    return $self-&gt;$orig(@_);
};</code></pre>
</div>

<div class="slide">
  <h1>Augment and Inner</h1>

  <ul>
    <li>Inverted <code>super</code></li>
    <li>From least- to most-specific</li>
    <li>Like Mason's autohandler feature</li>
    <li>Grandparent to parent to child</li>
    <li>Not allowed in roles</li>
  </ul>
</div>

<div class="slide">
  <h1>Augment and Inner</h1>

  <pre class="medium"><code>package Document;

sub xml { '&lt;doc&gt;' . <span class="highlight">inner()</span> . '&lt;/doc&gt;' }

package Report;
extends 'Document';
<span class="highlight">augment xml</span> =&gt;
    sub { my $self = shift;
          $self-&gt;title() . <span class="highlight">inner()</span> . $self-&gt;summary() };

package TPSReport;
extends 'Report';
<span class="highlight">augment xml</span> =&gt;
    sub { my $self = shift;
          $self-&gt;tps_xml() . <span class="highlight">inner()</span> };</code></pre>
</div>

<div class="slide">
  <h1>Augment and Inner</h1>

  <ul>
    <li>When we call <code>$tps-&gt;xml</code> ...
      <ul>
        <li><code>Document-&gt;xml</code></li>
        <li><code>Report-&gt;xml</code></li>
        <li><code>TPSReport-&gt;xml</code></li>
      </ul>
    </li>
  </ul>
</div>

<div class="slide">
  <h1>Augment and Inner Usage</h1>

  <ul>
    <li>Call <code>inner()</code> to "fill in the blank"</li>
    <li>Requires designing for subclassing</li>
    <li>Call <code>inner()</code> in the terminal class, just in case</li>
  </ul>
</div>

<div class="slide">
  <h1>Method Modifiers Summary</h1>

  <ul>
    <li>Use <code>before</code> and <code>after</code> for ...
      <ul>
        <li>logging</li>
        <li>pre- or post-validation</li>
        <li>to add behavior to generated methods</li>
      </ul>
    </li>
    <li>These two modifiers cannot change parameters or return values</li>
  </ul>
</div>

<div class="slide">
  <h1>Method Modifiers Summary</h1>

  <ul>
    <li>Use <code>around</code> to ...
      <ul>
        <li>alter parameters passed to the original method</li>
        <li>alter the return value of the original method</li>
        <li>not call the original method at all (or call a <em>different</em> method)</li>
      </ul>
    </li>
  </ul>
</div>

<div class="slide">
  <h1>Method Modifiers Summary</h1>

  <ul>
    <li>When using modifiers in a role, require the modified method</li>
    <li>Use <code>augment</code> and <code>inner</code> to invert the normal subclassing flow ...
      <ul>
        <li>Least- to most-specific (parents to children)</li>
        <li>Build in "insertability" (stick more stuff in the "middle")</li>
      </ul>
    </li>
    <li>Always call <code>inner</code> in the most specific subclass to allow for future extension</li>
  </ul>
</div>

<div class="slide">
  <h1>Questions?</h1>
</div>  

<div class="slide">
  <h1>Exercises</h1>

  <pre># cd exercises
# perl bin/prove -lv \
      t/04-method-modifiers.t

Iterate til this passes all its tests</pre>
</div>

<div class="slide fake-slide0">
  <h1>Part 5: Types</h1>
</div>

<div class="slide">
  <h1>A Type System for Perl</h1>

  <ul>
    <li>Sort of ...</li>
    <li><em>Variables</em> are not typed</li>
    <li>Attributes can have types</li>
    <li>MooseX modules let you define method signatures</li>
  </ul>
</div>

<div class="slide">
  <h1>Components of a Moose Type</h1>

  <ul>
    <li>A type is a name and a constraint</li>
    <li>Types have a hierarchy</li>
    <li>Constraints are cumulative from parents</li>
    <li>Types can have associated coercions</li>
  </ul>
</div>

<div class="slide">
  <h1>Built-in Type Hierarchy</h1>

  <pre>
Any
Item
    Bool
    Maybe[`a]
    Undef
    Defined
        Value
            Str
                Num
                    Int
                ClassName
                RoleName
</pre>
</div>

<div class="slide">
  <h1>Built-in Type Hierarchy</h1>

<pre>
(Item)
    (Defined)
        (Value)
        Ref
            ScalarRef
            ArrayRef[`a]
            HashRef[`a]
            CodeRef
            RegexpRef
            GlobRef
                FileHandle
            Object
</pre>
</div>

<div class="slide">
  <h1>Bool</h1>

  <h2>True</h2>
  <pre><code>1
924.1
'true'
{}</code></pre>

  <h2>False</h2>
  <pre><code>0
0.0
'0'
undef</code></pre>

  <ul>
    <li>Like Perl's <code>if ($foo)</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Value (and subtypes)</h1>

  <ul>
    <li><code>Value</code> is true when <code>! ref $thing</code></li>
    <li><code>Value</code> and <code>Str</code> are effectively the same, but <code>Str</code> is more expressive</li>
    <li><code>Num</code> is true when a <code>$scalar</code> looks like a number</li>
    <li>An overloaded object which numifies does not pass the <code>Num</code> constraint!</li>
    <li>Perl 5's overloading is hopelessly broken</li>
  </ul>
</div>

<div class="slide">
  <h1>ClassName and RoleName</h1>

  <ul>
    <li>A string with a package name</li>
    <li>The package <strong>must already be loaded</strong></li>
  </ul>
</div>

<div class="slide">
  <h1>Parameterizable Types</h1>

  <ul>
    <li>What does <code>ArrayRef[`a]</code> mean?</li>
    <li><code>s/`a/Int/</code> (or <code>Str</code> or ...)</li>
    <li>When you use it you can write ...
      <ul>
        <li><code>ArrayRef</code> (== <code>ArrayRef[Item]</code>)</li>
        <li><code>ArrayRef[Str]</code></li>
        <li><code>ArrayRef[MyTypeName]</code></li>
        <li><code>ArrayRef[HashRef[Maybe[Int]]]</code></li>
      </ul>
    </li>
  </ul>
</div>

<div class="slide">
  <h1>Maybe[`a]</h1>

  <ul>
    <li>Maybe means either the named type or <code>undef</code></li>
    <li><code>Maybe[Int]</code> accepts integers or <code>undef</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Type Union</h1>

  <ul>
    <li>This or that (or that or ...)</li>
    <li><code>Int | ArrayRef[Int]</code></li>
    <li>But use a coercion instead when possible</li>
    <li>Or use a <code>role_type</code>,  <code>duck_type</code>, or anything not a union</li>
    <li>A union is often a code smell</li>
  </ul>
</div>

<div class="slide">
  <h1>Making Your Own Types</h1>

  <pre><code>use Moose::Util::TypeConstraints;

<span class="incremental current">subtype 'PositiveInt',</span>
    <span class="incremental">as      'Int',</span>
    <span class="incremental">where   { $_ &gt; 0 },</span>
    <span class="incremental">message
        { "The value you provided ($_)"
          . " was not a positive int." };</span>

has size =&gt; (
    is  =&gt; 'ro',
    <span class="incremental">isa =&gt; 'PositiveInt',</span>
);</code></pre>
</div>

<div class="slide">
  <h1>Automatic Types</h1>

  <ul>
    <li>Moose creates a type for every Moose class and role</li>
    <li>Unknown names are assumed to be classes</li>
  </ul>
</div>

<div class="slide">
  <h1>Automatic Types</h1>

  <pre><code>package Employee;
use Moose;

has manager =&gt; (
    is  =&gt; 'rw',
    <span class="highlight">isa =&gt; 'Employee',</span>
);

has start_date =&gt; (
    is  =&gt; 'ro',
    <span class="highlight">isa =&gt; 'DateTime',</span>
);</code></pre>
</div>

<div class="slide">
  <h1>Subtype Shortcuts - <code>class_type</code></h1>

  <pre><code>use Moose::Util::TypeConstraints;
class_type 'DateTime';</code></pre>

<hr />

<pre><code>subtype     'DateTime',
    as      'Object',
    where   { $_-&gt;isa('DateTime') },
    message { ... };</code></pre>
</div>

<div class="slide">
  <h1>Subtype Shortcuts - <code>role_type</code></h1>

  <pre><code>use Moose::Util::TypeConstraints;
role_type 'Printable';</coe></pre>

<hr />

<pre><code>subtype 'Printable',
    as  'Object',
    where
        { Moose::Util::does_role(
              $_, 'Printable' ) },
    message { ... };</code></pre>
</div>

<div class="slide">
  <h1>Subtype Shortcuts - <code>duck_type</code></h1>

  <pre><code>use Moose::Util::TypeConstraints;
duck_type Car =&gt; qw( run break_down );</code></pre>

<hr />

<pre><code>subtype 'Car',
    as      'Object',
    where   { all { $_-&gt;can($_) }
              qw( run break_down ) },
    message { ... };</code></pre>
</div>

<div class="slide">
  <h1>Subtype Shortcuts - <code>enum</code></h1>

  <pre><code>use Moose::Util::TypeConstraints;
enum Color =&gt; qw( red blue green );</code></pre>

<hr />

<pre><code>my %ok = map { $_ =&gt; 1 }
             qw( red blue green );

subtype     'Color'
    as      'Str',
    where   { $ok{$_} },
    message { ... };</code></pre>
</div>

<div class="slide">
  <h1>Anonymous Subtypes</h1>

  <pre><code>package Person;

<span class="highlight">my $posint =
    subtype as 'Int', where { $_ &gt; 0 };</span>

has size =&gt; (
    is  =&gt; 'ro',
    <span class="highlight">isa =&gt; $posint,</span>
);</code></pre>

  <ul>
    <li>Shortcuts have anonymous forms as well</li>
  </ul>
</div>

<div class="slide">
  <h1>Coercions</h1>

  <pre><code>use Moose::Util::TypeConstraints;

subtype 'UCStr',
    as    'Str',
    where { ! /[a-z]/ };</code></pre>
</div>

<div class="slide">
  <h1>Coercions</h1>

  <pre><code><span class="incremental current">coerce 'UCStr',</span>
    <span class="incremental">from 'Str',</span>
    <span class="incremental">via  { uc };</span>

has shouty_name =&gt; (
    is     =&gt; 'ro',
    isa    =&gt; 'UCStr',
    <span class="incremental">coerce =&gt; 1,</span>
);</code></pre>
</div>

<div class="slide">
  <h1>Coercion Examples</h1>

  <pre><code>subtype 'My::DateTime',
    as class_type 'DateTime';

coerce 'My::DateTime',
    from 'HashRef',
    via  { DateTime-&gt;new( %{$_} ) };

coerce 'My::DateTime',
    from 'Int',
    via  { DateTime-&gt;from_epoch(
               epoch =&gt; $_ ) };</code></pre>

  <ul>
    <li>Use coercion to inflate a value</li>
  </ul>
</div>

<div class="slide">
  <h1>Coercion Examples</h1>

  <pre><code>coerce 'ArrayRef[Int]',
    from 'Int',
    via  { [ $_ ] };</code></pre>

  <ul>
    <li>Instead of union - <code style="white-space: nowrap">Int | ArrayRef[Int]</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Using Types with Attributes</h1>

  <pre><code>package Person;

has height =&gt; (
    is  =&gt; 'rw',
    <span class="highlight">isa =&gt; 'Num',</span>
);

has favorite_numbers =&gt; (
    is     =&gt; 'rw',
    <span class="highlight">isa    =&gt; 'ArrayRef[Int]',
    coerce =&gt; 1,</span>
);</code></pre>
</div>

<div class="slide">
  <h1>More Droppings</h1>

  <ul>
    <li><code>Moose::Util::TypeConstraints</code> also needs cleanup</li>
  </ul>

  <pre><code>package Person;

use Moose;
use Moose::Util::TypeConstraints;

subtype ...;

no Moose;
<span class="highlight">no Moose::Util::TypeConstraints;</span></code></pre>
</div>

<div class="slide">
  <h1>Questions So Far?</h1>
</div>  

<div class="slide">
  <h1>Exercises</h1>

  <pre># cd exercises
# perl bin/prove -lv t/05-types.t

Iterate til this passes all its tests</pre>
</div>

<div class="slide">
  <h1>Typed Methods (Low-tech)</h1>

  <pre class="medium"><code>package Person;
<span class="highlight">use MooseX::Params::Validate qw( validated_list );</span>

sub work {
    my $self = shift;
    <span class="highlight">my ( $tasks, $can_rest ) =
        validated_list(
            \@_,
            tasks    =&gt;
                { isa    =&gt; 'ArrayRef[Task]',
                  coerce =&gt; 1 },
            can_rest =&gt;
                { isa     =&gt; 'Bool',
                  default =&gt; 0 },
        );</span>
    ...
}</code></pre>
</div>

<div class="slide">
  <h1>Typed Methods (High-tech)</h1>

  <pre class="medium"><code>package Person;

<span class="highlight">use MooseX::Method::Signatures;</span>

<span class="highlight">method work ( ArrayRef[Task] :$tasks,
                        Bool :$can_rest = 0 )</span> {
    my $self = shift;

    ...
}</code></pre>
</div>

<div class="slide">
  <h1>Digression: The Type Registry</h1>

  <ul>
    <li>Types are actually <code>Moose::Meta::TypeConstraints</code> <em>objects</em></li>
    <li>Stored in an interpreter-global registry mapping names to objects</li>
  </ul>
</div>

<div class="slide">
  <h1>Danger!</h1>

  <ul>
    <li>Coercions are attached to type objects</li>
    <li>Therefore also global</li>
    <li>Name conflicts between modules!</li>
    <li>Coercion conflicts between modules!</li>
  </ul>
</div>

<div class="slide">
  <h1>Namespace Fix</h1>

  <ul>
    <li>Use some sort of pseudo-namespacing scheme</li>
    <li>Never coerce directly to a class name, or <em>to</em> built-in types</li>
  </ul>
</div>

<div class="slide">
  <h1>Namespace Fix</h1>

  <pre><code>use Moose::Util::TypeConstraints;
subtype <span class="highlight">'MyApp::Type::DateTime',</span>
    as 'DateTime';

<span class="highlight">coerce 'MyApp::Type::DateTime',</span>
    from 'HashRef',
    via  { DateTime-&gt;new( %{$_} ) }

has creation_date =&gt; (
    is     =&gt; 'ro',
    <span class="highlight">isa    =&gt; 'MyApp::Type::DateTime',</span>
    coerce =&gt; 1,
);</code></pre>
</div>

<div class="slide">
  <h1>Namespace Fix</h1>

  <pre><code>subtype 'MyApp::Type::ArrayOfInt',
    as 'ArrayRef[Int]';

coerce 'MyApp::Type::ArrayOfInt',
    from 'Int',
    via  { [ $_ ] };</code></pre>
</div>

<div class="slide">
  <h1>Namespace Fix Pros and Cons</h1>

  <ul>
    <li><span class="right">Relatively simple</span></li>
    <li><span class="right">Already built into Moose</span></li>
    <li><span class="wrong">Conflates type and module namespaces</span></li>
    <li><span class="wrong">Type names are strings, so typos are easy to make and may be hard to find</span></li>
  </ul>
</div>

<div class="slide">
  <h1>MooseX::Types</h1>

  <pre><code>package MyApp::Types;

use MooseX::Types
    <span class="highlight">-declare =&gt; [ qw( ArrayOfInt ) ]</span>;
use MooseX::Types::Moose
    qw( ArrayRef Int );

subtype <span class="highlight">ArrayOfInt</span>,
    as ArrayRef[Int];

coerce <span class="highlight">ArrayOfInt</span>
    from Int,
    via  { [ $_ ] };</code></pre>
</div>

<div class="slide">
  <h1>MooseX::Types</h1>

  <pre><code>package MyApp::Account;

use MyApp::Types qw( ArrayOfInt );

has transaction_history => (
    is  => 'rw',
    isa => ArrayOfInt,
);</code></pre>
</div>

<div class="slide">
  <h1>MooseX::Types</h1>

  <ul>
    <li>Type names are exported functions, catches typos early</li>
    <li>Types must be pre-declared</li>
    <li>Types are stored with namespaces internally, but you use short names</li>
    <li>Import existing Moose types as functions from <code>MooseX::Types::Moose</code></li>
    <li>Still need string names for things like <code>ArrayRef['Email::Address']</code></li>
  </ul>
</div>

<div class="slide">
  <h1>MooseX::Types Pros and Cons</h1>

  <ul>
    <li><span class="right">Catches typos at compile time</span></li>
    <li><span class="right">Automatic namespacing</span></li>
    <li><span class="wrong">One more thing to install and learn</span></li>
    <li><span class="wrong">Every name is typed twice (declared and then defined)</span></li>
    <li><span class="wrong">Still stuck with strings when referring to class or role names</span></li>
    <li><span class="wrong">Coercion gotcha from earlier still applies to types exported from <code>MooseX::Types::Moose</code></span></li>
  </ul>
</div>

<div class="slide">
  <h1>Recommendation</h1>

  <ul>
    <li>Use <code>MooseX::Types</code></li>
    <li>Compile time error catching and automatic namespacing are huge wins</li>
    <li>Docs from <code>Moose::Util::TypeConstraints</code> are 98% compatible with <code>MooseX::Types</code> anyway</li>
    <li>A function exported by a type library works wherever a type name would</li>
  </ul>
</div>

<div class="slide">
  <h1>Questions?</h1>
</div>  

<div class="slide fake-slide0">
  <h1>Part 6: Advanced Attributes</h1>
</div>

<div class="slide">
  <h1>Weak References</h1>

  <ul>
    <li>A weak reference lets you avoid circular references</li>
    <li>Weak references do not increase the reference count</li>
  </ul>
</div>

<div class="slide">
  <h1>Circular Reference Illustrated</h1>

  <pre><code>my $foo = {};
my $bar = { foo =&gt; $foo };
$foo-&gt;{bar} = $bar;</code></pre>

  <ul>
    <li>Neither <code>$foo</code> nor <code>$bar</code> go out of scope<br />
        (until the program exits)</li>
  </ul>
</div>

<div class="slide">
  <h1>Weakening Circular References</h1>

  <pre><code>use Scalar::Util qw( weaken );

my $foo = {};
my $bar = { foo =&gt; $foo };
$foo-&gt;{bar} = $bar;
weaken $foo-&gt;{bar}</code></pre>

  <ul>
    <li>When <code>$bar</code> goes out of scope, <code>$foo-&gt;{bar}</code> becomes <code>undef</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Circular References in Attributes</h1>

  <pre><code>package Person;
use Moose;

has name   =&gt; ( is =&gt; 'ro' );
has friend =&gt; ( is =&gt; 'rw' );

my $alice = Person-&gt;new( name =&gt; 'Alice' );
my $bob   = Person-&gt;new( name =&gt; 'Bob' );
$bob-&gt;friend($alice);
$alice-&gt;friend($bob);</code></pre>
</div>

<div class="slide">
  <h1>The Fix</h1>

  <pre><code>package Person;
use Moose;

has name   =&gt; ( is =&gt; 'ro' );
has friend =&gt; ( is       =&gt; 'rw',
                <span class="highlight">weak_ref =&gt; 1</span> );

my $alice = Person-&gt;new( name =&gt; 'Alice' );
my $bob   = Person-&gt;new( name =&gt; 'Bob' );
$bob-&gt;friend($alice);
$alice-&gt;friend($bob);</code></pre>
</div>

<div class="slide">
  <h1>Under the Hood</h1>

  <ul>
    <li>A <code>weak_ref</code> attribute calls <code>weaken</code> ...
      <ul>
        <li>during object construction</li>
        <li>when the attribute is set via a writer</li>
      </ul>
    </li>
  </ul>
</div>

<div class="slide">
  <h1>Triggers</h1>

  <ul>
    <li>A code reference run after an attribute is <em>set</em></li>
    <li>Like an <code>after</code> modifier, but makes intentions clearer</li>
  </ul>

  <h2 class="wrong">Gross</h2>

  <pre><code>after salary_level =&gt; {
    my $self = shift;
    <span class="highlight">return unless @_;</span>
    $self-&gt;clear_salary;
};</code></pre>
</div>

<div class="slide">
  <h1>Use a Trigger Instead</h1>

  <h2 class="right">Cleaner</h2>

  <pre><code>has salary_level =&gt; (
    is      =&gt; 'rw',
    trigger =&gt;
        sub { $_[0]-&gt;clear_salary },
);</code></pre>
</div>

<div class="slide">
  <h1>Trigger Arguments</h1>

  <ul>
    <li><code>$self</code></li>
    <li><code>$new_value</code></li>
    <li><code>$old_value</code> - if one exists</li>
  </ul>
</div>

<div class="slide">
  <h1>Delegation</h1>

  <ul>
    <li>Attributes can be objects</li>
    <li>Delegation transparently calls methods on those objects</li>
  </ul>
</div>

<div class="slide">
  <h1>Delegation Examples</h1>

  <pre><code>package Person;

has lungs =&gt; (
    is      =&gt; 'ro',
    isa     => 'Lungs',
    <span class="highlight">handles =&gt; [ 'inhale', 'exhale' ],</span>
);</code></pre>

  <ul>
    <li>Creates <code>$person-&gt;inhale</code> and <code>-&gt;exhale</code> methods</li>
    <li>Internally calls <code>$person-&gt;lungs-&gt;inhale</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Why Delegation?</h1>

  <ul>
    <li>Reduce the number of classes exposed</li>
    <li>Re-arrange class internals -<br />
        turn a method into an attribute with delegation</li>
    <li>Provide convenenience methods</li>
  </ul>
</div> 

<div class="slide">
  <h1>Moose's <code>handles</code> Parameter</h1>

  <ul>
    <li>Accepts many arguments ...
      <ul>
        <li>Array reference - list of methods to delegate as-is</li>
        <li>Hash reference - map of method names</li>
        <li>Regex - delegates all matching methods</li>
        <li>Role name - delegates all methods in the role</li>
        <li>Sub reference - does something complicated ;)</li>
      </ul>
    </li>
  </ul>
</div>      

<div class="slide">
  <h1>Array Reference</h1>

  <ul>
    <li>1-to-1 mapping</li>
    <li>Takes each method name and creates a simple delegation from the delegating class to the delegatee attribute</li>
  </ul>
</div>

<div class="slide">
  <h1>Hash Reference</h1>

  <ul>
    <li>Mapping of names in the delegating class to the delegatee class</li>
  </ul>

  <pre><code>package Person;
use Moose;
has account =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; 'BankAccount',
    <span class="highlight">handles =&gt; {
        receive_money =&gt; 'deposit',
        give_money    =&gt; 'withdraw',
    },</span>
);</code></pre>
</div>

<div class="slide">
  <h1>Hash Reference Detailed</h1>

  <pre><code>    handles =&gt; {
        receive_money =&gt; 'deposit',
        give_money    =&gt; 'withdraw',
    },</code></pre>

  <ul>
    <li><code>$person-&gt;receive_money</code> = <code>$person-&gt;account-&gt;deposit</code></li>
    <li><code>$person-&gt;give_money</code> = <code>$person-&gt;account-&gt;withdraw</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Regex</h1>

  <pre><code>package Person;
use Moose;

has name =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; 'Name',
    handles =&gt; qr/.*/,
);</code></pre>

  <ul>
    <li>Creates a delegation for every method in the Name class</li>
    <li>Excludes <code>meta</code> and methods inherited from <code>Moose::Object</code></li>
  </ul>
</div>

<div class="slide">
  <h1>Role Name</h1>

  <pre><code>package Auditor;
use Moose::Role;
sub record_change  { ... }
sub change_history { ... }

package Account;
use Moose;

has history =&gt; (
    is      =&gt; 'ro',
    does    =&gt; 'Auditor',
    <span class="highlight">handles =&gt; 'Auditor',</span>
);</code></pre>
</div>

<div class="slide">
  <h1>Role Name Detailed</h1>

  <ul>
    <li>Account gets delegate methods for each method in the <code>Auditor</code> role
      <ul>
        <li>record_history</li>
        <li>change_history</li>
      </ul>
    </li>
  </ul>
</div>

<div class="slide">
  <h1>Native Delegation</h1>

  <ul>
    <li>Delegate to <em>unblessed</em> Perl types</li>
    <li>Scalar, array or hash ref, etc</li>
    <li>Treat Perl types as objects</li>
    <li>Still uses <code>handles</code></li>
    <li>Pretend that native Perl types have methods</li>
  </ul>
</div>

<div class="slide">
  <h1>Native Delegation - Array(Ref)</h1>

  <ul>
    <li>Methods include:
      <ul>
        <li><code>push</code></li>
        <li><code>shift</code></li>
        <li><code>elements</code> - returns all elements</li>
        <li><code>count</code></li>
        <li><code>is_empty</code></li>
        <li>quite a few more</li>
      </ul>
    </li>
  </ul>
</div>

<div class="slide">
  <h1>Native Delegation - Array(Ref)</h1>

  <pre><code>package Person;
use Moose;
has _favorite_numbers =&gt; (
    traits   =&gt; [ 'Array' ],
    is       =&gt; 'bare',
    isa      =&gt; 'ArrayRef[Int]',
    default  =&gt; sub { [] },
    init_arg =&gt; undef,
    <span class="highlight">handles  =&gt;
      { favorite_numbers    =&gt; 'elements',
        add_favorite_number =&gt; 'push',
      },</span>
);</code></pre>
</div>

<div class="slide">
  <h1>Native Delegation - Array(Ref)</h1>

  <pre><code>my $person = Person-&gt;new();

$person-&gt;add_favorite_number(7);
$person-&gt;add_favorite_number(42);

print "$_\n"
    for $person-&gt;favorite_numbers;

# 7
# 42</code></pre>
</div>

<div class="slide">
  <h1>Native Delegation</h1>

  <ul>
    <li>Native types are ...
      <ul>
        <li>Number - <code>add</code>, <code>mul</code>, ...</li>
        <li>String - <code>append</code>, <code>chop</code>, ...</li>
        <li>Counter - <code>inc</code>, <code>dec</code>, ...</li>
        <li>Bool - <code>set</code>, <code>toggle</code>, ...</li>
        <li>Hash - <code>get</code>, <code>set</code>, ...</li>
        <li>Array - already saw it</li>
        <li>Code - <code>execute</code> and <code>execute_method</code></li>
      </ul>
    </li>
  </ul>
</div>

<div class="slide">
  <h1>Curried Delegation</h1>

  <ul>
    <li>A delegation with some preset arguments</li>
    <li>Works with object or Native delegation</li>
  </ul>
</div>

<div class="slide">
  <h1>Curried Delegation</h1>

  <pre><code>package Person;
use Moose;
has account =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; 'BankAccount',
    handles =&gt; {
        receive_100 =&gt;
            <span class="highlight">[ 'deposit', 100 ]</span>
        give_100    =&gt;
            <span class="highlight">[ 'withdraw', 100 ]</span>
    },
);</code></pre>
</div>

<div class="slide">
  <h1>Curried Delegation</h1>

  <pre><code>$person-&gt;receive_100;
# really is
$person-&gt;account-&gt;deposit(100);</code></pre>
</div>

<div class="slide">
  <h1>Traits and Metaclasses</h1>

  <ul>
    <li>The ultimate in customization</li>
    <li>Per attribute metaclasses</li>
    <li>Per attribute roles applied to the attribute metaclass</li>
    <li>Change the meta-level behavior</li>
  </ul>
</div>

<div class="slide">
  <h1>Traits and Metaclasses</h1>

  <ul>
    <li>The default metaclass is <code>Moose::Meta::Attribute</code></li>
    <li>Controls accessor generation, defaults, delegation, etc.</li>
    <li>Adding a role to this metaclass (or replacing it) allows for infinite customization</li>
  </ul>
</div>

<div class="slide">
  <h1>Traits and Metaclasses</h1>

  <ul>
    <li>Can add/alter/remove an attribute parameter (from <code>has</code>)</li>
    <li>Can change behavior of created attribute</li>
  </ul>
</div>

<div class="slide">
  <h1>Simple Trait Example</h1>

  <pre><code>package Person;
use Moose;
use MooseX::LabeledAttributes;

has ssn =&gt; (
    <span class="highlight">traits =&gt; [ 'Labeled' ],</span>
    is     =&gt; 'ro',
    isa    =&gt; 'Str',
    <span class="highlight">label  =&gt; 'Social Security Number',</span>
);
print <span class="highlight">Person-&gt;meta
            -&gt;get_attribute('ssn')-&gt;label;</span></code></pre>
</div>

<div class="slide">
  <h1>Simple Metaclass Example</h1>

  <pre><code>package Person;
use Moose;
use MooseX::LabeledAttributes;

has ssn =&gt; (
    <span class="highlight">metaclass =&gt;
        'MooseX::Meta::Attribute::Labeled',</span>
    is        =&gt; 'ro',
    isa       =&gt; 'Str',
    <span class="highlight">label     =&gt; 'Social Security Number',</span>
);
print <span class="highlight">Person-&gt;meta
            -&gt;get_attribute('ssn')-&gt;label;</span></code></pre>
</div>

<div class="slide">
  <h1>Traits vs Metaclass</h1>

  <ul>
    <li>Can apply any mix of traits to an attribute</li>
    <li>But just one metaclass</li>
    <li>Traits (aka roles) can cooperate</li>
    <li>Metaclasses require you to pick just one</li>
  </ul>
</div>

<div class="slide">
  <h1>Advanced Attributes Summary</h1>

  <ul>
    <li>Use <code>weak_ref</code> to avoid circular references</li>
    <li>Use trigger to do an action post-attribute write</li>
    <li>Use delegations to hide "internal" objects</li>
    <li>Use native delegations to treat Perl types as objects</li>
    <li>Traits and metaclasses let you extend Moose's core attribute features</li>
  </ul>
</div>

<div class="slide">
  <h1>Exercises</h1>

  <pre># cd exercises
# perl bin/prove -lv \
      t/06-advanced-attributes.t

Iterate til this passes all its tests</pre>
</div>

<div class="slide">
  <h1>CYOA</h1>

  <p>
    If there is time, keep going ...
  </p>

  <p>
    Otherwise, jump to slide 269 ...
  </p>
</div>

<div class="slide fake-slide0">
  <h1>Bonus: A Brief Tour of MooseX</h1>
</div>

<div class="slide">
  <h1>Notable MX Modules on CPAN</h1>

  <ul>
    <li><strong>Not comprehensive</strong></li>
    <li>152 MooseX distributions on CPAN as of 02/02/2010</li>
    <li>Some of them are crap</li>
  </ul>
</div>

<div class="slide">
  <h1>Already Mentioned Several</h1>

  <ul>
    <li><code>MooseX::NonMoose</code> - best solution for subclassing non-Moose parents</li>
    <li><code>MooseX::Declare</code> - <em>real</em> Perl 5 OO</li>
    <li><code>MooseX::FollowPBP</code> and <code>MooseX::SemiAffordanceAccessor</code></li>
    <li><code>MooseX::Params::Validate</code> and <code>MooseX::Method::Signatures</code></li>
    <li><code>MooseX::Types</code></li>
  </ul>
</div>    

<div class="slide">
  <h1>MooseX::Declare</h1>

<pre><code>use MooseX::Declare;
use 5.10.0; # for say

class Person {
    has greeting =&gt;
        ( is =&gt; 'ro', isa =&gt; 'Str' );

    method speak {
        say $self-&gt;greeting;
    }
}</code></pre>
</div>

<div class="slide">
  <h1>MooseX::Declare</h1>

  <ul>
    <li>Still experimental-ish, but seeing more and more use</li>
    <li><strong>Not</strong> a source filter!</li>
    <li>Hooks into the Perl parser rather than filtering all your code</li>
    <li>But not supported by <code>PPI</code>, <code>perltidy</code>, etc.</li> (yet?)
  </ul>
</div>

<div class="slide">
  <h1>MooseX::StrictConstructor</h1>

  <ul>
    <li>By default, unknown constructor arguments are ignored</li>
    <li>MX::StrictConstructor turns these into an error</li>
  </ul>
</div>

<div class="slide">
  <h1>MooseX::StrictConstructor</h1>

  <pre><code>package Person;

use Moose;
<span class="highlight">use MooseX::StrictConstructor;</span>

has name =&gt; ( is =&gt; 'ro' );

Person-&gt;new
    ( na<span class="wrong">n</span>e =&gt; 'Ringo Shiina' ); # kaboom</code></pre>
</div>

<div class="slide">
  <h1>MooseX::Traits</h1>

  <ul>
    <li>Combines object construction and role application</li>
    <li>Makes it easy to create one-off customized objects</li>
  </ul>
</div>

<div class="slide">
  <h1>MooseX::Traits</h1>

  <pre><code>package MyApp::Thingy;
use Moose;

<span class="highlight">with 'MooseX::Traits';</span>

my $thing =
    MyApp::Thingy-&gt;<span class="highlight">new_with_traits</span>
        ( <span class="highlight">traits =&gt; [ 'Foo', 'Bar' ],</span>
          size   =&gt; 42 );</code></pre>
</div>

<div class="slide">
  <h1>MooseX::Getopt</h1>

  <ul>
    <li>Makes command-line interface programs easy!</li>
    <li>Construct an object from CLI arguments</li>
  </ul>
</div>

<div class="slide">
  <h1>MooseX::Getopt</h1>

  <pre><code>package App::CLI;
use Moose;

<span class="highlight">with 'MooseX::Getopt';</span>

has file    =&gt;
    ( is =&gt; 'ro', required =&gt; 1 );
has filters =&gt;
    ( is =&gt; 'ro', isa =&gt; 'ArrayRef[Str]' );

sub run { ... }</code></pre>
</div>

<div class="slide">
  <h1>MooseX::Getopt</h1>

  <ul>
    <li>Then call it like this:</li>
  </ul>

<pre><code>#!/usr/bin/perl

use App::CLI;

<span class="highlight">App::CLI-&gt;new_with_options()</span>-&gt;run();</code></pre>

<pre>$ myapp-cli \
   --file foo \
   --filters compress \
   --filters sanitize</pre>
</div>

<div class="slide">
  <h1>MooseX::Clone</h1>

  <pre><code>package Person;

use Moose;
<span class="highlight">with 'MooseX::Clone';</span>

my $person = Person-&gt;new;
my $clone  = <span class="highlight">$person-&gt;clone;</span></code></pre>
</div>

<div class="slide">
  <h1>MooseX::NonMoose</h1>

  <ul>
    <li>Highly recommended for subclassing non-Moose parents</li>
    <li>Gets all the little annoying details right</li>
  </ul>
</div>

<div class="slide">
  <h1>MooseX::Role::Parameterized</h1>

  <pre><code>package HasCollection;
<span class="current incremental">use MooseX::Role::Parameterized;</span>
<span class="incremental">parameter type =&gt; ( isa     =&gt; 'Str',
                    default =&gt; 'Item' );</span>
<span class="incremental">role {
    my $p = shift;

    my $type =
        'ArrayRef[' . $p-&gt;type() . ']';
    has collection =&gt;
        ( is  =&gt; 'ro',
          isa =&gt; $type );
};</span></code></pre>
</div>

<div class="slide">
  <h1>MooseX::Role::Parameterized</h1>

  <pre><code>package Person;

use Moose;
with HasCollection =&gt; { type =&gt; 'Int' };</code></pre>
</div>

<div class="slide">
  <h1>Questions?</h1>
</div>  

<div class="slide">
  <h1>Moose-using Modules</h1>

  <p>
    For further reading, a few modules which use Moose ...
  </p>

  <ul>
    <li><a href="http://search.cpan.org/dist/Catalyst-Runtime">Catalyst</a></li>
    <li><a href="http://search.cpan.org/dist/CHI">CHI</a></li>
    <li><a href="http://search.cpan.org/dist/Devel-REPL">Devel::REPL</a></li>
    <li><a href="http://search.cpan.org/dist/Email-Sender">Email::Sender</a></li>
    <li><a href="http://search.cpan.org/dist/Fey">Fey</a></li>
    <li><a href="http://search.cpan.org/dist/Net-Twitter">Net::Twitter</a></li>
  </ul>
</div>

<div class="slide">
  <h1>More Information</h1>

  <ul>
    <li><a href="http://moose.perl.org/">http://moose.perl.org/</a></li>
    <li><a href="http://search.cpan.org/dist/Moose/lib/Moose/Manual.pod">Moose::Manual</a> and <a href="http://search.cpan.org/dist/Moose/lib/Moose/Cookbook.pod">Moose::Cookbook</a></li>
    <li><a href="irc://irc.perl.org/#moose">irc://irc.perl.org/#moose</a></li>
    <li>mailing list - <a href="mailto:moose@perl.org">moose@perl.org</a></li>
    <li>Slides and exercises are in Moose's git repo:
        <br />
        <span style="font-size:80%; white-space: nowrap">git://jules.scsys.co.uk/gitmo/moose-presentations</span></li>
  </ul>
</div>

<div class="slide fake-slide0">
  <h1>The End</h1>
</div>

</div> 
</body>
</html>

<!--

Copyright 2009 David Rolsky. All Rights Reserved.

This work is licensed under a Creative Commons Attribution-Share Alike
3.0 United States License See
http://creativecommons.org/licenses/by-sa/3.0/us/ for details.

-->
